{
  "version": 3,
  "sources": ["../../node_modules/@reach/observe-rect/dist/observe-rect.esm.js", "../../@tanstack/react-virtual/src/useIsomorphicLayoutEffect.ts", "../../@tanstack/react-virtual/src/useRect.ts", "../../@tanstack/react-virtual/src/index.tsx"],
  "sourcesContent": ["var props = [\"bottom\", \"height\", \"left\", \"right\", \"top\", \"width\"];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n", "import * as React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n", "import React from 'react'\nimport observeRect from '@reach/observe-rect'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\nfunction rectReducer(state: Rect, action: { rect: Rect }) {\n  const rect = action.rect\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n\nexport const useRect = <T extends HTMLElement>(\n  nodeRef: React.RefObject<T>,\n  initialRect: Rect = { width: 0, height: 0 },\n) => {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, initialRect)\n\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect()\n      dispatch({ rect })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, (rect) => {\n      dispatch({ rect })\n    })\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n", "import * as React from 'react'\nimport { useRect, Rect } from './useRect'\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = (index: number) => index\n\nconst defaultMeasureSize = (el: HTMLElement, horizontal: boolean) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ninterface ScrollToOptions {\n  align: ScrollAlignment\n}\n\ninterface ScrollToOffsetOptions extends ScrollToOptions {}\n\ninterface ScrollToIndexOptions extends ScrollToOptions {}\n\nexport interface Range {\n  start: number\n  end: number\n  overscan: number\n  size: number\n}\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\ntype Key = number | string\n\ninterface Item {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n}\n\nexport interface VirtualItem extends Item {\n  measureRef: (el: HTMLElement | null) => void\n}\n\nexport interface Options<T> {\n  size: number\n  parentRef: React.RefObject<T>\n  estimateSize?: (index: number) => number\n  overscan?: number\n  horizontal?: boolean\n  scrollToFn?: (\n    offset: number,\n    defaultScrollToFn?: (offset: number) => void,\n  ) => void\n  paddingStart?: number\n  paddingEnd?: number\n  useObserver?: (ref: React.RefObject<T>, initialRect?: Rect) => Rect\n  initialRect?: Rect\n  keyExtractor?: (index: number) => Key\n  onScrollElement?: React.RefObject<HTMLElement>\n  scrollOffsetFn?: (event?: Event) => number\n  rangeExtractor?: (range: Range) => number[]\n  measureSize?: (el: HTMLElement, horizontal: boolean) => number\n}\n\nexport const useVirtual = <T extends HTMLElement>({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal = false,\n  scrollToFn,\n  useObserver,\n  initialRect,\n  onScrollElement,\n  scrollOffsetFn,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n}: Options<T>) => {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n\n  const latestRef = React.useRef<{\n    scrollOffset: number\n    measurements: Item[]\n    outerSize: number\n    totalSize: number\n  }>({\n    outerSize: 0,\n    scrollOffset: 0,\n    measurements: [],\n    totalSize: 0,\n  })\n\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  latestRef.current.scrollOffset = scrollOffset\n\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef, initialRect)\n\n  latestRef.current.outerSize = outerSize\n\n  const defaultScrollToFn = React.useCallback(\n    (offset: number) => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey],\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  const scrollTo = React.useCallback(\n    (offset: number) => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn],\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState<Record<Key, number>>(\n    {},\n  )\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef<number[]>([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || paddingStart) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n\n  const scrollOffsetFnRef = React.useRef(scrollOffsetFn)\n  scrollOffsetFnRef.current = scrollOffsetFn\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setScrollOffset(0)\n\n      return\n    }\n\n    const onScroll = (event?: Event) => {\n      const offset = scrollOffsetFnRef.current\n        ? scrollOffsetFnRef.current(event)\n        : element[scrollKey]\n\n      setScrollOffset(offset)\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey])\n\n  const { start, end } = calculateRange(latestRef.current)\n\n  const indexes = React.useMemo(\n    () =>\n      rangeExtractor({\n        start,\n        end,\n        overscan,\n        size: measurements.length,\n      }),\n    [start, end, overscan, measurements.length, rangeExtractor],\n  )\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems: VirtualItem[] = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: (el: HTMLElement | null) => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache((old) => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [indexes, defaultScrollToFn, horizontal, measurements])\n\n  const mountedRef = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (\n      toOffset: number,\n      { align }: ScrollToOffsetOptions = { align: 'start' },\n    ) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollTo(toOffset)\n      } else if (align === 'end') {\n        scrollTo(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollTo(toOffset - outerSize / 2)\n      }\n    },\n    [scrollTo],\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (\n      index: number,\n      { align, ...rest }: ScrollToIndexOptions = { align: 'auto' },\n    ) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size],\n  )\n\n  const scrollToIndex = React.useCallback(\n    (index: number, options?: ScrollToIndexOptions) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(index, options)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(index, options)\n      })\n    },\n    [tryScrollToIndex],\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: Item[]\n  outerSize: number\n  scrollOffset: number\n}) {\n  const size = measurements.length - 1\n  const getOffset = (index: number) => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  return { start, end }\n}\n"],
  "mappings": "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",
  "names": ["rectChanged", "run", "useIsomorphicLayoutEffect", "window", "useLayoutEffect", "useEffect", "rectReducer", "state", "action", "rect", "height", "width", "useRect", "nodeRef", "initialRect", "React", "useState", "current", "element", "setElement", "useReducer", "dispatch", "initialRectSet", "useRef", "getBoundingClientRect", "observer", "observeRect", "observe", "unobserve", "defaultEstimateSize", "defaultKeyExtractor", "index", "defaultMeasureSize", "el", "horizontal", "key", "defaultRangeExtractor", "range", "start", "Math", "max", "overscan", "end", "min", "size", "arr", "i", "push", "useVirtual", "estimateSize", "paddingStart", "paddingEnd", "parentRef", "scrollToFn", "useObserver", "onScrollElement", "scrollOffsetFn", "keyExtractor", "measureSize", "rangeExtractor", "sizeKey", "scrollKey", "latestRef", "outerSize", "scrollOffset", "measurements", "totalSize", "setScrollOffset", "useMeasureParent", "defaultScrollToFn", "useCallback", "offset", "resolvedScrollToFn", "scrollTo", "measuredCache", "setMeasuredCache", "measure", "pendingMeasuredCacheIndexesRef", "useMemo", "length", "slice", "measuredSize", "scrollOffsetFnRef", "onScroll", "event", "addEventListener", "capture", "passive", "removeEventListener", "calculateRange", "indexes", "measureSizeRef", "virtualItems", "_loop", "k", "len", "measurement", "item", "measureRef", "old", "mountedRef", "scrollToOffset", "toOffset", "align", "tryScrollToIndex", "rest", "scrollToIndex", "options", "requestAnimationFrame", "findNearestBinarySearch", "low", "high", "getCurrentValue", "value", "middle", "currentValue", "getOffset"]
}
