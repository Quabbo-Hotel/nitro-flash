import {
  ObservablePoint,
  Point,
  Rectangle
} from "./chunk-X7XBKDSX.js";
import "./chunk-NKHIPFFU.js";

// node_modules/@pixi/math-extras/dist/esm/math-extras.mjs
var mixins = {
  add: function(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x + other.x;
    outPoint.y = this.y + other.y;
    return outPoint;
  },
  subtract: function(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x - other.x;
    outPoint.y = this.y - other.y;
    return outPoint;
  },
  multiply: function(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x * other.x;
    outPoint.y = this.y * other.y;
    return outPoint;
  },
  multiplyScalar: function(scalar, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x * scalar;
    outPoint.y = this.y * scalar;
    return outPoint;
  },
  dot: function(other) {
    return this.x * other.x + this.y * other.y;
  },
  cross: function(other) {
    return this.x * other.y - this.y * other.x;
  },
  normalize: function(outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    var magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
    outPoint.x = this.x / magnitude;
    outPoint.y = this.y / magnitude;
    return outPoint;
  },
  magnitude: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  magnitudeSquared: function() {
    return this.x * this.x + this.y * this.y;
  },
  project: function(onto, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    var normalizedScalarProjection = (this.x * onto.x + this.y * onto.y) / (onto.x * onto.x + onto.y * onto.y);
    outPoint.x = onto.x * normalizedScalarProjection;
    outPoint.y = onto.y * normalizedScalarProjection;
    return outPoint;
  },
  reflect: function(normal, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    var dotProduct = this.x * normal.x + this.y * normal.y;
    outPoint.x = this.x - 2 * dotProduct * normal.x;
    outPoint.y = this.y - 2 * dotProduct * normal.y;
    return outPoint;
  }
};
Object.assign(Point.prototype, mixins);
Object.assign(ObservablePoint.prototype, mixins);
Rectangle.prototype.containsRect = function containsRect(other) {
  if (other.width <= 0 || other.height <= 0) {
    return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;
  }
  return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;
};
Rectangle.prototype.equals = function equals(other) {
  if (other === this) {
    return true;
  }
  return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
};
Rectangle.prototype.intersection = function intersection(other, outRect) {
  if (!outRect) {
    outRect = new Rectangle();
  }
  var x0 = this.x < other.x ? other.x : this.x;
  var x1 = this.right > other.right ? other.right : this.right;
  if (x1 <= x0) {
    outRect.x = outRect.y = outRect.width = outRect.height = 0;
    return outRect;
  }
  var y0 = this.y < other.y ? other.y : this.y;
  var y1 = this.bottom > other.bottom ? other.bottom : this.bottom;
  if (y1 <= y0) {
    outRect.x = outRect.y = outRect.width = outRect.height = 0;
    return outRect;
  }
  outRect.x = x0;
  outRect.y = y0;
  outRect.width = x1 - x0;
  outRect.height = y1 - y0;
  return outRect;
};
Rectangle.prototype.union = function union(other, outRect) {
  if (!outRect) {
    outRect = new Rectangle();
  }
  var x1 = Math.min(this.x, other.x);
  var x2 = Math.max(this.x + this.width, other.x + other.width);
  var y1 = Math.min(this.y, other.y);
  var y2 = Math.max(this.y + this.height, other.y + other.height);
  outRect.x = x1;
  outRect.y = y1;
  outRect.width = x2 - x1;
  outRect.height = y2 - y1;
  return outRect;
};
function floatEqual(a, b, epsilon) {
  if (epsilon === void 0) {
    epsilon = Number.EPSILON;
  }
  if (a === b) {
    return true;
  }
  var diff = Math.abs(a - b);
  return diff < epsilon;
}
function genericLineIntersection(aStart, aEnd, bStart, bEnd, isLine, outPoint) {
  if (!outPoint) {
    outPoint = new Point();
  }
  var dxa = aEnd.x - aStart.x;
  var dya = aEnd.y - aStart.y;
  var dxb = bEnd.x - bStart.x;
  var dyb = bEnd.y - bStart.y;
  var denominator = dyb * dxa - dxb * dya;
  if (floatEqual(denominator, 0)) {
    outPoint.x = NaN;
    outPoint.y = NaN;
    return outPoint;
  }
  var ua = (dxb * (aStart.y - bStart.y) - dyb * (aStart.x - bStart.x)) / denominator;
  var ub = (dxa * (aStart.y - bStart.y) - dya * (aStart.x - bStart.x)) / denominator;
  if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1)) {
    outPoint.x = NaN;
    outPoint.y = NaN;
    return outPoint;
  }
  outPoint.x = aStart.x + ua * dxa;
  outPoint.y = bStart.y + ub * dyb;
  return outPoint;
}
function lineIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
  return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);
}
function segmentIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
  return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);
}
export {
  floatEqual,
  lineIntersection,
  segmentIntersection
};
//# sourceMappingURL=@pixi_math-extras.js.map
